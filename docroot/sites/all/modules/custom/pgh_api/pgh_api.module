<?php

/**
 * @file
 * Awards API module. Provides functions for getting information about objects in the awards system.
 *
 * @author Jay Roberts <jay@designhammer.com>
 */

/**
 * Returns an array of Work Group nodes for the current user.
 *
 * @return array
 *   An array of Work Group nodes which the user is related to either directly or by being in
 *   a child Business Unit.
 *
 * @author Jay Roberts <jay@designhammer.com>
 */
function pgh_api_work_groups_for_user() {
  global $user;

  $nids = array();

  // Find Work Groups that the user is an administrator of.
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
                  ->propertyCondition('type', 'work_group')
                  ->fieldCondition('field_administrators', 'target_id', $user->uid)
                  ->execute();

  if (isset($result['node'])) {
    $nids = array_keys($result['node']);
  }

  // Find Work Groups where the user is a Business Unit User.
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
                ->propertyCondition('type', 'business_unit')
                ->fieldCondition('field_users', 'target_id', $user->uid)
                ->execute();

  if (isset($result['node'])) {
    $business_unit_nids = array_keys($result['node']);
    foreach ($business_unit_nids as $business_unit_nid) {
      $work_groups = pgh_api_work_groups_for_business_unit($business_unit_nid);
      foreach ($work_groups as $work_group) {
        $nids[] = $work_group->nid;
      }
    }
  }

  // Load all of the nids as full nodes.
  $nids = array_unique($nids);

  $work_groups = array();
  foreach ($nids as $nid) {
    $work_groups[] = node_load($nid);
  }

  return $work_groups;
}

/**
 * Returns all of the Work Group nodes which have a reference to the specified Business Unit node.
 *
 * @param int $business_unit_nid
 *   This nid of the Business Unit to find a Work Group for.
 *
 * @return object
 *   An array of fully loaded Work Group nodes which have references to the specified Business Unit or an empty array if not found.
 */
function pgh_api_work_groups_for_business_unit($business_unit_nid) {
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
                  ->propertyCondition('type', 'work_group')
                  ->fieldCondition('field_business_units', 'target_id', $business_unit_nid)
                  ->execute();

  if (isset($result['node'])) {
    $work_groups = array();
    $nids = array_keys($result['node']);
    foreach ($nids as $nid) {
      $work_groups[] = node_load($nid);
    }
    return $work_groups;
  }

  return array();
}

/**
 * Returns the Business Unit node which owns the specified Application node.
 *
 * @param int $application_nid
 *   This nid of the Application to find a Business Unit for.
 *
 * @return object
 *   A fully loaded Business Unit node which is the owner of the specified Application, or FALSE if not found.
 */
function pgh_api_business_unit_for_application($application_nid) {
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
                  ->propertyCondition('type', 'business_unit')
                  ->fieldCondition('field_applications', 'target_id', $application_nid)
                  ->execute();

  if (isset($result['node'])) {
    $nids = array_keys($result['node']);
    return node_load($nids[0]);
  }

  return FALSE;
}


/**
 * Returns an Application Type node based on the supplied id.
 *
 * @param string $application_type_id
 *   A string identifier for the application type, NOT a node id.
 *
 * @return object
 *   An Application Type node or FALSE if not found.
 *
 * @author  Jay Roberts <jay@designhammer.com>
 */
function pgh_api_application_type_by_id($application_type_id) {
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
                  ->propertyCondition('type', 'apptype')
                  ->propertyCondition('title', $application_type_id)
                  ->execute();

  if (isset($result['node'])) {
    $nids = array_keys($result['node']);
    return node_load($nids[0]);
  }

  return FALSE;
}


/**
 * Returns nid(s) based on a supplied pgh item key id.
 *
 * @param string $key
 *   A category key.
 *
 * @param string $type
 *   Type of the item
 *
 * @param bool $all
 *   If all matching nid are returned, or just the first one, default FALSE
 *
 * @return int
 *   The nid for the supplied id or 0 if not found.
 *   Or array of nids if $all = TRUE
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_api_find_nid($key, $type, $all = FALSE) {
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
                  ->propertyCondition('type', $type)
                  ->propertyCondition('title', $key)
                  ->execute();
  if (!empty($result['node'])) {
    $keys = array_keys($result['node']);
    if ($all) {
      return $keys;
    }
    else {
      return $keys[0];
    }
  }
  else {
    return 0;
  }
}

/**
 * Returns nid(s) based on a supplied entity and property conditions.
 *
 * @param array $property_conds
 *   Type of the item
 *
 * @param array $field_conds
 *   Type of the item
 *
 * @param bool $all
 *   If all matching nid are returned, or just the first one, default FALSE
 *
 * @param array $entity_conds
 *   A category key.
 *
 * @return int
 *   The nid for the supplied id or 0 if not found.
 *   Or array of nids if $all = TRUE
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_api_node_ids($property_conds = array(), $field_conds = array(), $all = FALSE, $entity_conds = array()) {
  $query = new EntityFieldQuery();
  $entity_default = array(
    'entity_type' => 'node'
  );
  $entity_conds = array_merge($entity_default, $entity_conds);
  foreach ($entity_conds as $key => $value) {
    $query->entityCondition($key, $value);
  }
  foreach ($property_conds as $key => $value) {
    $query->propertyCondition($key, $value);
  }
  foreach ($field_conds as $key => $value) {
    $query->fieldCondition($key, 'value', $value);
  }

  $result = $query->execute();
  if (!empty($result['node'])) {
    $keys = array_keys($result['node']);
    if ($all) {
      return $keys;
    }
    else {
      return $keys[0];
    }
  }
  else {
    return 0;
  }
}

/**
 * Validate question based on validation rules and value.
 *
 * For additional context regarding validation behavior, see:
 * https://ac.designhammer.net/projects/practice-greenhealth-phase-1/tasks/301
 *
 * @param string $validations
 *   Validation rules string delimited by comma
 *
 * @param array $value
 *   Value needs to be validated
 *
 * @return array
 *   An array containing zero or more error arrays. Each error array has a 'type' and 'message' property. These are strings.
 *   Type can be 'warning' or 'error'. 'message' is a user-facing validation message.
 *
 * @author Fang Jin <fang@designhammer.com>
 * @author Jay Roberts <jay@designhammer.com>
 */
function pgh_api_validate_question_value($validations, $value) {
  if (!trim($validations)) {
    return array();
  }

  $errors = array();
  $rules = array_map('trim', explode(',', $validations));

  // Process specified rules.
  foreach ($rules as $rule) {
    $invalid = FALSE;

    switch ($rule) {
      case 'nonnegative':
        $invalid = (!is_numeric($value) || $value < 0);
        $error = array(
          'type' => 'warning',
          'message' => t('This value must be a positive number or zero.'),
        );
        break;

      case 'integer':
        // Check if $value is an integer or string representation of an integer.
        // is_int() will fail on the string values presented by the Form API.
        $invalid = !(((string) (int) $value) == $value);
        $error = array(
          'type' => 'warning',
          'message' => t('This value must be a whole number or zero.'),
        );
        break;

      case 'nonzero':
        $invalid = (!is_numeric($value) || $value == 0);
        $error = array(
          'type' => 'warning',
          'message' => t('This value must be a non-zero number.'),
        );
        break;

      case 'percentage':
        $is_int = (((string) (int) $value) == $value);
        $invalid = (!$is_int || $value < 0 || $value > 100);
        $error = array(
          'type' => 'warning',
          'message' => t('This value must be a whole number between 0 and 100.'),
        );
        break;

      case 'date':
        $invalid = (!preg_match('/^(19|20)\d\d-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$/', $value));
        $error = array(
          'type' => 'warning',
          'message' => t('This value must be a date in format YYYY-MM-DD.'),
        );
        break;

      case 'currency':
        $invalid = (filter_var($value, FILTER_VALIDATE_FLOAT, array('flags' => FILTER_FLAG_ALLOW_THOUSAND, 'decimal' => 2)) === FALSE);
        $error = array(
          'type' => 'warning',
          'message' => t('This value must be in US currency with no $ sign.'),
        );
        break;

      case 'required':
        $invalid = ($value === '' || $value === NULL);
        $error = array(
          'type' => 'error',
          'message' => t('This field is required.'),
        );
        break;

      default:
        $invalid = TRUE;
        $error = array(
          'type' => 'warning',
          'message' => t('Unsupported validation rule: %rule', array('%rule' => $rule)),
        );
        break;
    }

    $required = in_array('required', $rules);
    $empty = $value === '' || $value === NULL;

    // To display error, you need to be either empty && required or non-empty && invalid.
    if ($required && $empty || !$empty && $invalid) {
      $errors[] = $error;
    }
  }

  return $errors;
}

/**
 * Returns all NIDs of responses for one application.
 *
 * @param int $app_id
 *   NID for a specific application instance.
 *
 * @return array
 *   Array of int
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_api_responses_ids_for_application($app_id) {
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
                  ->propertyCondition('type', 'response')
                  ->fieldCondition('field_response_application', 'target_id', $app_id)
                  ->execute();
  if (!empty($result['node'])) {
    $keys = array_keys($result['node']);
    return $keys;
  }
  else {
    return 0;
  }
}

/**
 * Returns the NID for a response based on a supplied application NID and question NID.
 *
 * @param int $app_id
 *   NID for a specific application instance.
 *
 * @param int $qid
 *   NID for a specific question instance.
 *
 * @return int
 *   The NID for the supplied question id or 0 if not found.
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_api_find_response_id($app_id, $qid) {
  // TODO: This function accepts an app NID and a question NID and returns a response NID. The naming makes
  // it seem like it returns a response ID (which is not a real thing in the system).
  // Should be renamed to pgh_api_nid_for_response($app_nid, $question_nid)
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
                  ->propertyCondition('type', 'response')
                  ->fieldCondition('field_response_application', 'target_id', $app_id)
                  ->fieldCondition('field_response_question', 'target_id', $qid)
                  ->execute();
  if (!empty($result['node'])) {
    $keys = array_keys($result['node']);
    return $keys[0];
  }
  else {
    return 0;
  }
}

/**
 * Load the nid of the response for a given question.
 *
 * @param int $app_id
 *   NID for a specific application instance.
 *
 * @param int $qid
 *   NID for a specific question instance.
 *
 * @return array
 *   A response array, passed by reference. This will be set to an array containing 'value' and 'points' elements.
 *
 * @author Fang Jin <fang@designhammer.com>
 * @author Jay Roberts <jay@designhammer.com>
 */
function pgh_api_get_response($app_id, $qid) {
  $rid = pgh_api_find_response_id($app_id, $qid);
  $response = array(
    'value' => '',
    'point' => 0,
    'score' => 0,
    'kpi' => 0,
    'updated' => 0,
  );
  if ($rid) {
    $response_node = node_load($rid);
    $wrapper = entity_metadata_wrapper('node', $response_node);
    $kpi = $wrapper->field_response_kpi->value();

    $response = array(
      'value' => $wrapper->body->value() ? $wrapper->body->value->raw() : '',
      'point' => $wrapper->field_response_point->value(),
      'score' => $wrapper->field_response_score->value(),
      'kpi' => ($kpi === NULL) ? '~' : $kpi,
      'updated' => $wrapper->field_response_updated->value(),
    );
  }
  else {
    watchdog('pgh_api', 'Couldn\'t find response %rid for application %app_id' .
      ' - question %qid in pgh_api_get_response. Creating empty response.',
      array('%rid' => $rid, '%app_id' => $app_id, '%qid' => $qid), WATCHDOG_ERROR);

    // If a response is not found, automatically generate a new empty response. This will fix issues where an application is
    // in an inconsistent state (missing responses) due to an error on application creation or due to an administrator mistake.
    $rnid = pgh_api_set_response($app_id, $qid, array(), TRUE);
    if ($rnid) {
      return pgh_api_get_response($app_id, $qid);
    }
    else {
      return;
    }
  }

  return $response;
}

/**
 * Sets the stored value for the response to a specific application/question.
 *
 * If there is no response object this function will create one and set up the correct mappings.
 *
 * If this function is being used to create an empty response when a new Application is created
 * pass TRUE for the $is_new parameter.This will ensure that field_response_updated stays false
 * until an end user actually supplies a response.
 *
 * @param int $app_id
 *   NID for a specific application instance.
 *
 * @param int $qid
 *   NID for a specific question instance.
 *
 * @param array $answer
 *   An array specifying the value to store in the response.
 *
 * @param bool $is_new
 *   Boolean indicating whether or not this function is being called to generate a new response object.
 *   Defaults to FALSE. If TRUE, field_response_updated will not be modified.
 *
 * @return int
 *   The NID of the response which the answer was saved to.
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_api_set_response($app_id, $qid, $answer = array(), $is_new = FALSE) {
  // Set default answer.
  $default = array(
    'value' => '',
    'point' => 0,
    'score' => 0,
    'kpi' => '',
  );
  $answer = array_merge($default, $answer);

  // Find response.
  $rid = pgh_api_find_response_id($app_id, $qid);
  if ($rid) {
    $response = node_load($rid);
    $wrapper = entity_metadata_wrapper('node', $response);
  }
  else {
    // Create a new response.
    $response = entity_create('node', array('type' => 'response'));
    $wrapper = entity_metadata_wrapper('node', $response);
    $wrapper->field_response_application->set($app_id);
    $wrapper->field_response_question->set($qid);
  }
  $wrapper->title = 'app_' . $app_id . '_q_' . $qid;
  if ($answer) {
    $wrapper->body = array(
      'value' => $answer['value']
    );
    $wrapper->field_response_point->set($answer['point']);
    $wrapper->field_response_score->set($answer['score']);
    $wrapper->field_response_kpi->set($answer['kpi']);
  }
  if (!$is_new) {
    $wrapper->field_response_updated->set(1);
  }
  $wrapper->save();
  return $response->nid;
}


/**
 * Returns a boolean indicating if the question should be considered active.
 *
 * A Question is 'active' if it is not a dependent question or if all of the
 * questions up the dependency chain are not active. It is necessary to make this distinction
 * because Questions which are not active should not count as progress indicators and should not
 * display validation errors on the application review and submit page.
 *
 * This function recurses up the chain of question parents.
 *
 * @param int $application_nid
 *   The NID for the Application to check.
 *
 * @param int $question_nid
 *   The NID for the Question to check.
 *
 * @return bool
 *   A boolean indicating if the question should be considered active.
 *
 * @author  Jay Roberts <jay@designhammer.com>
 */
function pgh_api_question_is_active($application_nid, $question_nid) {
  $question = node_load($question_nid);

  if (!$question) {
    watchdog('pgh_api', 'Tried to load invalid question nid %id in pgh_api_question_is_active', array('%id' => $question_nid), WATCHDOG_ERROR);
    return FALSE;
  }

  $parent = field_get_items('node', $question, 'field_question_parent_qid');

  // Non-dependent questions are always active.
  if (!$parent) {
    return TRUE;
  }

  // Next we check to see if the parent response value is different from the Parent Required Value of this question.
  // We need to do a bit of object loading and value conversion.

  // Unbox the field value.
  $parent_qid = $parent[0]['value'];
  $parent_nid = pgh_api_find_nid($parent_qid, 'question');

  // Check for questions qhich specify themselves as their own parent. This causes a recursion loop if we don't exit here.
  if ($parent_nid == $question_nid) {
    drupal_set_message(t('Question %qid specifies itself as parent question id.', array('%qid' => $parent_qid)), 'error');
    return FALSE;
  }

  $question_parent_required_value = field_get_items('node', $question, 'field_question_parent_value');

  // Unbox the required value.
  if ($question_parent_required_value) {
    $question_parent_required_value = $question_parent_required_value[0]['value'];
  }

  // Convert the value to its internal representation.
  $question_parent_required_value = pgh_api_internal_value($parent_nid, $question_parent_required_value);

  // Fetch the parent question's response.
  $parent_response = node_load(pgh_api_find_response_id($application_nid, $parent_nid));

  if (!$parent_response) {
    watchdog('pgh_api', 'Tried to load invalid parent response %id in pgh_api_question_is_active', array('%id' => $parent_nid), WATCHDOG_ERROR);
    return FALSE;
  }

  $parent_response_wrapper = entity_metadata_wrapper('node', $parent_response);
  $parent_response_value = $parent_response_wrapper->body->value() ? $parent_response_wrapper->body->value->raw() : '';

  // If the parent's response value doesn't match the required value for this question, then this question is not active.
  if ($parent_response_value != $question_parent_required_value) {
    return FALSE;
  }

  // If the values match, we are only active if our parent is also active.
  return pgh_api_question_is_active($application_nid, $parent_nid);
}

/**
 * Converts an externally specified Response value into its internal representation.
 *
 * Specifically, for selects , it converts option text ('Yes', 'No') into its numerical representation
 * (0, 1). For other question types it returns the original value.
 *
 * This is an ugly function and it is only necessary because the system uses two distinct representations
 * for question values.
 *
 * @param int $question_nid
 *   The NID of the speicifc question.
 *
 * @param mixed $value
 *   A value, likely from field_parent_value.
 *
 * @return mixed
 *   The representation of $value as it would be stored in a Response object.
 *
 * @author Jay Roberts <jay@designhammer.com>
 */
function pgh_api_internal_value($question_nid, $value) {
  $question = node_load($question_nid);
  $question_wrapper = entity_metadata_wrapper('node', $question);
  $question_type = $question_wrapper->field_question_type->value();

  switch ($question_type) {
    case 'selection':
      $options = $question_wrapper->field_question_options->value();
      return array_search($value, $options);

    default:
      return $value;
  }
}


/**
 * Save a question value to its response.
 *
 * @param int $app_id
 *   NID for a specific application instance.
 *
 * @param int $qid
 *   NID for a specific question instance.
 *
 * @param array $value
 *   Quesiton value
 *
 * @return int
 *   The NID of the response which the answer was saved to.
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_api_save_response($app_id, $qid, $value) {
  if (!($application = node_load($app_id))) {
    watchdog(
      'pgh',
      'Missing application %app in saving response.',
      array('%app' => $app_id),
      WATCHDOG_ERROR
    );
    return;
  }
  $application_wrapper = entity_metadata_wrapper('node', $application);
  if ($application_wrapper->field_application_status->value() == 'new') {
    $application_wrapper->field_application_status->set('in-progress');
    $application_wrapper->save();
  }

  $question = node_load($qid);
  $question_wrapper = entity_metadata_wrapper('node', $question);
  $type = $question_wrapper->field_question_type->value();
  $style = $question_wrapper->field_question_style->value();

  // Save response if the question expects a response.
  if (!in_array($type, array('html', 'container'))) {
    // To differentiate the name of question and response
    // Response is prefixed with r_, point is potential point.

    // Fetch question spec for scores.
    $point = $question_wrapper->field_question_point->value();
    $score = $question_wrapper->field_question_score->value();
    $kpi = $question_wrapper->field_question_kpi->value();

    // Assign points to response.
    $r_point = 0; $r_score = 0; $r_kpi = '';
    switch ($type) {
      case 'text':
      case 'file':
        if (!empty($point[0])) {
          $r_point = $point[0];
        }
        if (!empty($value)) {
          if (!empty($score[0])) {
            $r_score = $score[0];
          }
          if (isset($kpi[0])) {
            $r_kpi = $kpi[0];
          }
        }
        break;

      case 'selection':
        switch ($style) {
          case 'checkboxes':
            if ($point) {
              $r_point = array_sum($point);
            }
            $options = $question_wrapper->field_question_options->value();
            $i = 0;
            foreach ($options as $option) {
              if (!empty($value[$option])) {
                if (!empty($score[$i])) {
                  $r_score += $score[$i];
                }
                if (isset($kpi[$i])) {
                  $r_kpi += $kpi[$i];
                }
              }
              $i++;
            }
            // Serialize only applies to checkboxes.
            $value = serialize($value);
            break;

          case 'dropdown':
            if ($point) {
              $r_point = max($point);
            }
            if (!empty($score[$value])) {
              $r_score = $score[$value];
            }
            if (isset($kpi[$value])) {
              $r_kpi = $kpi[$value];
            }
            break;

          case 'radios':
          default:
            if (!empty($point[$value])) {
              $r_point = $point[$value];
            }
            if (!empty($score[$value])) {
              $r_score = $score[$value];
            }
            if (isset($kpi[$value])) {
              $r_kpi = $kpi[$value];
            }
            break;
        }
        break;

      default:
        // Should be error message.
        break;
    }

    $answer = array(
      'value' => $value,
      'point' => $r_point,
      'score' => $r_score,
      'kpi' => $r_kpi,
    );
    pgh_api_set_response($app_id, $qid, $answer);
  }
}

/**
 * Returns an options array of all of the Work Groups in the system.
 *
 * @return array
 *   An options array of Work Groups.
 *
 * @author Jay Roberts <jay@designhammer.com>
 */
function pgh_api_all_work_groups_options() {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
        ->entityCondition('bundle', 'work_group');
  $results = $query->execute();
  $nodes = node_load_multiple(array_keys($results['node']));

  $options = array();
  foreach ($nodes as $node) {
    $options[$node->nid] = $node->title;
  }
  return $options;
}

/**
 * Returns a keyed array of valid Application Types for the supplied business unit.
 *
 * @param object $business_unit
 *   A Business Unit node.
 *
 * @return array
 *   A an array of Application Types. Keys are machine names, values are descriptions.
 *
 * @author  Jay Roberts <jay@designhammer.com>
 */
function pgh_api_valid_application_types_for_business_unit($business_unit) {
  if (!$business_unit) {
    watchdog('pgh_api', 'Invalid business_unit supplied to pgh_api_valid_application_types_for_business_unit', array(), WATCHDOG_ERROR);
    return array();
  }
  $business_unit_wrapper = entity_metadata_wrapper('node', $business_unit);

  if (!$business_unit_wrapper) {
    watchdog('pgh_api', 'Couldn\'t create wrapper for business_unit in pgh_api_valid_application_types_for_business_unit', array(), WATCHDOG_ERROR);
    return array();
  }

  switch ($business_unit_wrapper->field_business_unit_type->value()) {
    case 'health_system':
      $types = array(
        'system_for_change' => 'System for Change',
      );
      return $types;

    case 'hospital':
      $types = array(
        'partner_for_change' => 'Partner for Change',
        'partner_recognition' => 'Partner Recognition',
        'mmmf' => 'Making Medicine Mercury Free',
        'greening_the_or' => 'Greening the OR',
        'dehp_free' => 'DEHP Free',
      );
      return $types;

    case 'long_term_care':
      $types = array(
        'long_term_care' => 'Partner for Change - Beds',
        'mmmf' => 'Making Medicine Mercury Free',
      );
      return $types;

    case 'clinic':
      $types = array(
        'chc_partner_for_change' => 'Partner for Change - No beds',
        'chc_partner_recognition' => 'CHC Partner Recognition',
      );
      return $types;

    case 'business_member':
      $types = array(
        'champion_for_change_gpo' => 'Champion for Change (GPO)',
        'champion_for_change_nongpo' => 'Champion for Change (Non-GPO)',
      );
      return $types;

    case 'strategic_associate_member':
      $types = array(
        'champion_for_change_nongpo' => 'Champion for Change (Non-GPO)',
      );
      return $types;

    default:
      return array();
  }
}


/**
 * Return an array of question nodes for a specified application nid.
 *
 * @param int $application_nid
 *   The NID of the application.
 *
 * @return array
 *   An array of Question nodes.
 *
 * @author  Jay Roberts <jay@designhammer.com>
 */
function pgh_api_questions_for_application($application_nid) {
  $questions = array();
  $application = node_load($application_nid);
  $application_wrapper = entity_metadata_wrapper('node', $application);

  $application_type = pgh_api_application_type_by_id($application_wrapper->field_application_type->value());
  $application_type_wrapper = entity_metadata_wrapper('node', $application_type);

  foreach ($application_type_wrapper->field_apptype_categories->getIterator() as $category_wrapper) {
    foreach ($category_wrapper->field_category_sections->getIterator() as $section_wrapper) {
      foreach ($section_wrapper->field_section_questions->getIterator() as $question_wrapper) {
        $questions[$question_wrapper->title->value()] = $question_wrapper->value();
      }
    }
  }

  return $questions;
}

/**
 * Return an array of question nodes for a specified application category.
 *
 * @param int $application_nid
 *   The NID of the application.
 *
 * @param int $category_nid
 *   The NID of the category.
 *
 * @return array
 *   An array of Question nodes.
 *
 * @author  Jay Roberts <jay@designhammer.com>
 */
function pgh_api_questions_for_category($application_nid, $category_nid) {
  $category = node_load($category_nid);
  $questions = array();

  $category_wrapper = entity_metadata_wrapper('node', $category);
  foreach ($category_wrapper->field_category_sections->getIterator() as $section_wrapper) {
    foreach ($section_wrapper->field_section_questions->getIterator() as $question_wrapper) {
      $questions[$question_wrapper->title->value()] = $question_wrapper->value();
    }
  }

  return $questions;
}


/**
 * Return an array of category nodes for a specified application nid.
 *
 * @param int $application_nid
 *   The NID of the application.
 *
 * @return array
 *   An array of Category nodes.
 *
 * @author  Jay Roberts <jay@designhammer.com>
 */
function pgh_api_categories_for_application($application_nid) {
  $categories = array();
  $application = node_load($application_nid);
  $application_wrapper = entity_metadata_wrapper('node', $application);

  $application_type = pgh_api_application_type_by_id($application_wrapper->field_application_type->value());

  if (!$application_type) {
    $variables = array(
      '%apptype' => $application_wrapper->field_application_type->value(),
    );
    watchdog('pgh_api', 'Could not load Application Type %apptype in pgh_api_categories_for_application', $variables, WATCHDOG_ERROR);
    return array();
  }

  $application_type_wrapper = entity_metadata_wrapper('node', $application_type);

  foreach ($application_type_wrapper->field_apptype_categories->getIterator() as $category_wrapper) {
    $categories[] = $category_wrapper->value();
  }

  return $categories;
}


/**
 * Calculate progress information for a specific application.
 *
 * Iterates through all Responses for the application and determines the total number of questions
 * and the total number of responses given. Returns responses / questions.
 *
 * @param int $application_nid
 *   NID for a specific application instance.
 *
 * @return float
 *   A float value from 0 to 1 indicating the total application progress.
 *
 * @author Jay Roberts <jay@designhammer.com>
 */
function pgh_api_progress_for_application($application_nid) {
  $category_count = 0;
  $progress = 0;

  $categories = pgh_api_categories_for_application($application_nid);

  foreach ($categories as $category) {
    $category_count++;
    $progress += pgh_api_progress_for_category($application_nid, $category->nid);
  }

  if ($category_count == 0) {
    return 0;
  }
  else {
    return $progress / $category_count;
  }
}

/**
 * Calculate progress for a specific application and category.
 *
 * Currently progress is the total number of active 'text', 'file', and 'selection' questions in
 * the category divided by the number of updated responses for those questions.
 *
 * @param int $application_nid
 *   The NID of the application.
 *
 * @param int $category_nid
 *   The NID of the category.
 *
 * @return float
 *   A float value from 0 to 1 indicating the total application progress.
 *
 * @author Jay Roberts <jay@designhammer.com>
 */
function pgh_api_progress_for_category($application_nid, $category_nid) {
  $application = node_load($application_nid);

  if (!$application) {
    watchdog('pgh_api', 'Tried to load invalid application nid %id in pgh_api_progress_for_category', array('%id' => $application_nid), WATCHDOG_ERROR);
    return 0;
  }

  $application_wrapper = entity_metadata_wrapper('node', $application);

  $category_progress = @unserialize($application_wrapper->field_category_progress->value());

  if ($category_progress === FALSE || !is_array($category_progress)) {
    return 0;
  }

  return isset($category_progress[$category_nid]) ? $category_progress[$category_nid] : 0;
}

/**
 * Calculate progress for a specific application and category.
 *
 * Progress is the total number of active 'text', 'file', and 'selection' questions in
 * the category divided by the number of updated responses for those questions.
 *
 * This function uses pgh_api_question_is_active to determine if the question should be included
 * in he progress calculation. This function is comparatively slow so we should only recalculate when
 * the category form is submitted. After recalculating, the progress value is saved to a serialized array
 * which is stored in a field o the Application node.
 *
 * This ensures that fetching progress for a category or whole application is always just a series of fast
 * lookups and calculation is never done on more than a category's worth of questions at a time.
 *
 * @param int $application_nid
 *   The NID of the application.
 *
 * @param int $category_nid
 *   The NID of the category.
 *
 * @return float
 *   A float value from 0 to 1 indicating the total category progress.
 *
 * @author Jay Roberts <jay@designhammer.com>
 */
function pgh_api_recalculate_progress_for_category($application_nid, $category_nid) {
  // Get all of the question/response pairs for a category.
  $query = "SELECT rq.entity_id AS response_id,
                   rq.field_response_question_target_id AS question_id,
                   ru.field_response_updated_value AS response_updated
            FROM field_data_field_response_question rq
            INNER JOIN field_data_field_response_application ra ON ra.entity_id = rq.entity_id
            INNER JOIN field_data_field_response_updated ru ON ru.entity_id = rq.entity_id
            WHERE
              ra.field_response_application_target_id = :application_nid AND
              rq.field_response_question_target_id IN (
                SELECT field_section_questions_target_id
                FROM (
                  SELECT field_section_questions_target_id
                  FROM field_data_field_section_questions s
                  INNER JOIN field_data_field_question_type qt ON qt.entity_id = s.field_section_questions_target_id
                  WHERE
                    s.entity_id IN (
                      SELECT field_category_sections_target_id FROM (
                        SELECT field_category_sections_target_id FROM field_data_field_category_sections c WHERE c.entity_id = :category_nid
                      ) x
                    ) AND
                    qt.field_question_type_value IN ('text', 'file', 'selection')
                ) y
              )";

  $results = db_query($query, array(':category_nid' => $category_nid, ':application_nid' => $application_nid));

  $question_count = 0;
  $response_count = 0;

  while ($result = $results->fetchObject()) {
    if (pgh_api_question_is_active($application_nid, $result->question_id)) {
      $question_count++;
      if ($result->response_updated) {
        $response_count++;
      }
    }
  }

  $progress = 0;

  if ($question_count != 0) {
    $progress = $response_count / $question_count;
  }

  // Store calculated progress in a serialized field on the Application.
  $application = node_load($application_nid);

  if (!$application) {
    watchdog('pgh_api', 'Tried to load invalid application nid %id in pgh_api_recalculate_progress_for_category', array('%id' => $application_nid), WATCHDOG_ERROR);
    return 0;
  }

  $application_wrapper = entity_metadata_wrapper('node', $application);

  $category_progress = @unserialize($application_wrapper->field_category_progress->value());

  if ($category_progress === FALSE || !is_array($category_progress)) {
    $category_progress = array();
  }

  $category_progress[$category_nid] = $progress;

  $application_wrapper->field_category_progress->set(serialize($category_progress));
  $application_wrapper->save();

  return $progress;
}

/**
 * Checks all of the questions in the supplied application category for validation errors.
 *
 * @param int $application_nid
 *   The NID of the application.
 *
 * @param int $category_nid
 *   The NID of the category.
 *
 * @return float
 *   A float value from 0 to 1 indicating the total application progress.
 *
 * @author Jay Roberts <jay@designhammer.com>
 */
function pgh_api_category_is_valid($application_nid, $category_nid) {
  $questions = pgh_api_questions_for_category($application_nid, $category_nid);

  $errors = array();

  foreach ($questions as $question) {
    $question_wrapper = entity_metadata_wrapper('node', $question);

    $response_array = pgh_api_get_response($application_nid, $question->nid);

    $errors = array_merge($errors, pgh_api_validate_question_value($question_wrapper->field_question_validation->value(), $response_array['value'], TRUE));

    if ($errors) {
      return FALSE;
    }
  }

  return TRUE;
}

/**
 * Returns an array of errors keyed on the question id for the supplied application category.
 *
 * @param int $application_nid
 *   The NID of the application.
 *
 * @param int $category_nid
 *   The NID of the category.
 *
 * @return array
 *   An array of errors keyed on question id.
 */
function pgh_api_errors_for_category($application_nid, $category_nid) {
  $questions = pgh_api_questions_for_category($application_nid, $category_nid);

  $errors = array();

  foreach ($questions as $question) {
    if (!pgh_api_question_is_active($application_nid, $question->nid)) {
      continue;
    }
    $question_wrapper = entity_metadata_wrapper('node', $question);

    $response_array = pgh_api_get_response($application_nid, $question->nid);

    $question_errors = pgh_api_validate_question_value($question_wrapper->field_question_validation->value(), $response_array['value'], TRUE);
    if ($question_errors) {
      $errors[$question->title] = $question_errors;
    }
  }

  return $errors;
}

/**
 * Adds the supplied user to the list of users for the Business Unit.
 *
 * @param object $user
 *   A Drupal user object.
 *
 * @param object $business_unit
 *   A Business Unit node.
 *
 * @author Jay Roberts <jay@designhammer.com>
 */
function pgh_api_add_user_to_business_unit($user, $business_unit) {
  $business_unit_wrapper = entity_metadata_wrapper('node', $business_unit);

  // Ignore duplicate additions.
  foreach ($business_unit_wrapper->field_users->getIterator() as $user_wrapper) {
    if ($user->uid == $user_wrapper->uid->value()) {
      return;
    }
  }

  $business_unit_wrapper->field_users[] = $user->uid;
  $business_unit_wrapper->save();
}

/**
 * Perform a mass operation on nodes.
 *
 * Perform a mass operation on nodes, switching based on the specified
 * operation. Currently supports updating and deleting, utilizing the atch
 * API for large numbers of updates.
 *
 * IMPORTANT NOTE: This function is intended to work when called
 * from a form submit handler. Calling it outside of the form submission
 * process may not work correctly.
 *
 * @param array $nodes
 *   Array of node nids to update.
 * @param string $op
 *   The operation to be performed (Currently either 'delete' or 'update')
 * @param array $updates
 *   Array of key/value pairs with node field names and the
 *   value to update that field to.
 *
 * @author Drupal Patch <noname@drupal.org>
 */
function node_mass_operation($nodes, $op, $updates = array()) {
  // We use batch processing to prevent timeout when updating a large umber
  // of nodes.
  if (count($nodes) > 10) {
    $batch = array(
      'operations' => array(
        array(
          '_node_mass_operation_batch_process',
          array($nodes, $op, 'updates')
        )
      ),
      'finished' => '_node_mass_operation_batch_finished',
      'title' => t('Processing'),
      // We use a single multi-pass operation, so the default
      // 'Remaining x of y operations' message will be confusing here.
      'progress_message' => '',
      'error_message' => t('The %op has encountered an error.', array('%op' => $op)),
    );
    batch_set($batch);
  }
  else {
    foreach ($nodes as $nid) {
      _node_mass_operation_helper($nid, $op, $updates);
    }
    drupal_set_message(t('The %op has been performed.', array('%op' => op)));
  }
}

/**
 * Node Mass Operation - helper function.
 *
 * @author Drupal Patch <noname@drupal.org>
 */
function _node_mass_operation_helper($nid, $op, $updates) {
  $node = node_load($nid, NULL, TRUE);

  switch ($op) {
    case 'update':
      foreach ($updates as $name => $value) {
        $node->$name = $value;
      }
      node_save($node);
      break;

    case 'delete':
      node_delete($nid);
      $node->nid = NULL;
      break;
  }

  return $node;

}

/**
 * Node Mass Operation Batch operation.
 *
 * @author Drupal Patch <noname@drupal.org>
 */
function _node_mass_operation_batch_process($nodes, $op, $updates, $context) {
  if (!isset($context['sandbox']['progress'])) {
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['max'] = count($nodes);
    $context['sandbox']['nodes'] = $nodes;
  }

  // Process nodes by groups of 5.
  $count = min(5, count($context['sandbox']['nodes']));
  for ($i = 1; $i <= $count; $i++) {
    // For each nid, call the opertion helper.
    $nid = array_shift($context['sandbox']['nodes']);

    $node = _node_mass_operation_helper($nid, $op, $updates);

    switch ($op) {
      case 'update':
        // Store result for post-processing in the finished callback.
        $context['results'][] = l($node->title, 'node/' . $node->nid);
        break;

      case 'delete':
        // Store result for post-processing in the finished callback.
        $context['results'][] = t(('Deleted ' . $node->title));
        break;
    }

    // Update our progress information.
    $context['sandbox']['progress']++;
  }

  // Inform the batch engine that we are not finished,
  // and provide an estimation of the completion level we reached.
  if ($context['sandbox']['progress'] != $context['sandbox']['max']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
}

/**
 * Node Mass Update Batch 'finished' callback.
 *
 * @author Drupal Patch <noname@drupal.org>
 */
function _node_mass_operation_batch_finished($success, $results, $operations) {
  if ($success) {
    drupal_set_message(t('The update has been performed.'));
  }
  else {
    drupal_set_message(t('An error occurred and processing did not complete.'), 'error');
    $message = format_plural(count($results), '1 item successfully processed:', '@count items successfully processed:');
    $message .= theme('item_list', $results);
    drupal_set_message($message);
  }
}

/**
 * Returns node nid(s) with filters and sorts.
 *
 * @param array $conds
 *   Condition entries, there're three different type of conditions
 *   1. prefixed with entity_, ex. 'entity_type' => 'node'
 *   2. prefixed with field_, ex. 'field_project',
 *      two formats allowed, simple version 'field_tag' => 'abc',
 *      or long version, 'field_tag' => array('target_id', 11, '=')
 *   3. no prefix or other prefix, 'title' => 'abc'
 *   Default $conds contains 'entity_type' => 'node' entry.
 *
 * @param array $sorts
 *   Sort entiries, there're two different type of sorts
 *   1. prefixed with field_, ex. 'field_tag' => array('target_id', 'ASC')
 *   2. no prefix or other prefix, 'title' => 'ASC'
 *   Default $sorts are empty
 *
 * @param bool $all
 *   If all matching nid are returned, or just the first one, default FALSE
 *
 * @return int
 *   The nid for the supplied id or 0 if not found.
 *   Or array of nids if $all = TRUE
 *
 * @author Fang Jin <windmaomao@gmail.com>
 */
function pgh_api_find_nodes($conds, $sorts = NULL, $all = FALSE, $range = NULL) {
  $conds = array_merge(array('entity_type' => 'node'), $conds);
  if (empty($sorts)) {
    $sorts = array();
  }

  $query = new EntityFieldQuery();

  // Apply condition to query.
  foreach ($conds as $key => $value) {
    $splits = explode('_', $key);
    $type = $splits[0];
    if (count($splits) == 1) {
      $type = 'property';
    }

    switch ($type) {
      case 'entity':
        $query->entityCondition($key, $value);
        break;

      case 'field':
        if (is_array($value)) {
          $property = isset($value[1]) ? $value[0] : 'value';
          $assigned = isset($value[1]) ? $value[1] : $value[0];
          $operator = isset($value[2]) ? $value[2] : '=';
          $query->fieldCondition($key, $property, $assigned, $operator);
        }
        else {
          $query->fieldCondition($key, 'value', $value);
        }
        break;

      // Rest of them are all property.
      default:
        $query->propertyCondition($key, $value);
        break;
    }
  }

  // Apply sort to query.
  foreach ($sorts as $key => $value) {
    $splits = explode('_', $key);
    $type = $splits[0];
    if (count($splits) == 1) {
      $type = 'property';
    }

    switch ($type) {
      case 'field':
        $query->fieldOrderBy($key, $value[0], $value[1]);
        break;

      default:
        $query->propertyOrderBy($key, $value);
        break;
    }
  }

  // Apply range.
  if (!empty($range)) {
    $rvars = array(0, 0);
    if (is_array($range)) {
      $rvars = $range;
    }
    else {
      $rvars[1] = $range;
    }
    $query->range($rvars[0], $rvars[1]);
  }

  $result = $query->execute();
  $ctype = $conds['entity_type'];
  if (!empty($result[$ctype])) {
    $keys = array_keys($result[$ctype]);
    if ($all) {
      return $keys;
    }
    else {
      return $keys[0];
    }
  }
  else {
    if ($all) {
      return array();
    }
    else {
      return 0;
    }
  }
}
