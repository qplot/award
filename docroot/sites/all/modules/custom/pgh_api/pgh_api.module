<?php

/**
 * @file
 * Awards API module. Provides functions for getting information about objects in the awards system.
 *
 * @author Jay Roberts <jay@designhammer.com>
 */

/**
 * Returns an array of Work Group nodes for the current user.
 *
 * @return array
 *   An array of Work Group nodes owned by the current user or an empty array if none found.
 *
 * @author Jay Roberts <jay@designhammer.com>
 */
function pgh_api_work_groups_for_user() {
  global $user;

  $nids = array();

  // Find Work Groups that the user is an administrator of.
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
                  ->propertyCondition('type', 'work_group')
                  ->fieldCondition('field_administrators', 'target_id', $user->uid)
                  ->execute();

  if (isset($result['node'])) {
    $nids = array_keys($result['node']);
  }

  // Find Work Groups where the user is a Business Unit User.
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
                ->propertyCondition('type', 'business_unit')
                ->fieldCondition('field_users', 'target_id', $user->uid)
                ->execute();

  if (isset($result['node'])) {
    $business_unit_nids = array_keys($result['node']);
    foreach ($business_unit_nids as $business_unit_nid) {
      $work_group = pgh_api_work_group_for_business_unit($business_unit_nid);
      if ($work_group) {
        $nids[] = $work_group->nid;
      }
    }
  }

  // Load all of the nids as full nodes.
  $nids = array_unique($nids);

  $work_groups = array();
  foreach ($nids as $nid) {
    $work_groups[] = node_load($nid);
  }

  return $work_groups;
}

/**
 * Returns the Work Group node which owns the specified Business Unit node.
 *
 * @param int $business_unit_nid
 *   This nid of the Business Unit to find a Work Group for.
 *
 * @return object
 *   A fully loaded Work Group node which is the owner of the specified Business Unit, or FALSE if not found.
 */
function pgh_api_work_group_for_business_unit($business_unit_nid) {
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
                  ->propertyCondition('type', 'work_group')
                  ->fieldCondition('field_business_units', 'target_id', $business_unit_nid)
                  ->execute();

  if (isset($result['node'])) {
    $nids = array_keys($result['node']);
    return node_load($nids[0]);
  }

  return FALSE;
}

/**
 * Returns the Business Unit node which owns the specified Application node.
 *
 * @param int $application_nid
 *   This nid of the Application to find a Business Unit for.
 *
 * @return object
 *   A fully loaded Business Unit node which is the owner of the specified Application, or FALSE if not found.
 */
function pgh_api_business_unit_for_application($application_nid) {
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
                  ->propertyCondition('type', 'business_unit')
                  ->fieldCondition('field_applications', 'target_id', $application_nid)
                  ->execute();

  if (isset($result['node'])) {
    $nids = array_keys($result['node']);
    return node_load($nids[0]);
  }

  return FALSE;
}

/**
 * Returns nid(s) based on a supplied pgh item key id.
 *
 * @param string $key
 *   A category key.
 *
 * @param string $type
 *   Type of the item
 *
 * @param bool $all
 *   If all matching nid are returned, or just the first one, default FALSE
 *
 * @return int
 *   The nid for the supplied id or 0 if not found.
 *   Or array of nids if $all = TRUE
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_api_find_nid($key, $type, $all = FALSE) {
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
                  ->propertyCondition('type', $type)
                  ->propertyCondition('title', $key)
                  ->execute();
  if (!empty($result['node'])) {
    $keys = array_keys($result['node']);
    if ($all) {
      return $keys;
    }
    else {
      return $keys[0];
    }
  }
  else {
    return 0;
  }
}

/**
 * Validate question based on validation rules and value.
 *
 * @param array $validations
 *   Validation rules string delimited by comma
 *
 * @param array $value
 *   Value needs to be validated
 *
 * @return array
 *   Array of string of error messages
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_api_validate_question_value($validations, $value) {
  $errors = array();
  $validates = explode(',', $validations);
  foreach ($validates as $validate) {
    switch (trim($validate)) {
      case 'nonnegative':
        if (!is_numeric($value) || $value < 0) {
          $errors[] = 'The item value needs to be a positive number.';
        }
        break;

      case 'integer':
        // Check if $value is an integer or string representation of an integer.
        // is_int() will fail on the string values presented by the Form API.
        $is_int = ((string) (int) $value) == $value;
        if (!$is_int) {
          $errors[] = 'The item value needs to be an integer.';
        }
        break;

      case 'nonzero':
        if (!is_numeric($value) || $value == 0) {
          $errors[] = 'The item value must be a non-zero number.';
        }
        break;

      case 'percentage':
        $is_int = ((string) (int) $value) == $value;
        if (!$is_int || $value < 0 || $value > 100) {
          $errors[] = 'The item value needs to be integer in the range 0 - 100';
        }
        break;

      default:
        $errors[] = 'Unsupported validation rule: ' . $validate;
        break;
    }
  }

  return $errors;
}

/**
 * Returns the NID for a response based on a supplied application NID and question NID.
 *
 * @param int $app_id
 *   NID for a specific application instance.
 *
 * @param int $qid
 *   NID for a specific question instance.
 *
 * @return int
 *   The NID for the supplied question id or 0 if not found.
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_api_find_response_id($app_id, $qid) {
  // TODO: This function accepts an app NID and a question NID and returns a response NID. The naming makes
  // it seem like it returns a response ID (which is not a real thing in the system).
  // Should be renamed to pgh_api_nid_for_response($app_nid, $question_nid)
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
                  ->propertyCondition('type', 'response')
                  ->fieldCondition('field_response_application', 'target_id', $app_id)
                  ->fieldCondition('field_response_question', 'target_id', $qid)
                  ->execute();
  if (!empty($result['node'])) {
    $keys = array_keys($result['node']);
    return $keys[0];
  }
  else {
    return 0;
  }
}

/**
 * Load the nid of the response for a given question.
 *
 * @param int $app_id
 *   NID for a specific application instance.
 *
 * @param int $qid
 *   NID for a specific question instance.
 *
 * @return
 *   A response array, passed by reference. This will be set to an array containing 'value' and 'points' elements.
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_api_get_response($app_id, $qid) {
  $rid = pgh_api_find_response_id($app_id, $qid);
  $response = array();
  if ($rid) {
    $response = node_load($rid);
    $wrapper = entity_metadata_wrapper('node', $response);

    $response = array(
      'value' => $wrapper->body->value->raw(),
      'point' => $wrapper->field_response_point->value(),
      'updated' => $wrapper->field_response_updated->value(),
    );
  }

  return $response;
}

/**
 * Sets the stored value for the response to a specific application/question.
 *
 * If there is no response object this function will create one and set up the correct mappings.
 *
 * If this function is being used to create an empty response when a new Application is created
 * pass TRUE for the $is_new parameter.This will ensure that field_response_updated stays false
 * until an end user actually supplies a response.
 *
 * @param int $app_id
 *   NID for a specific application instance.
 *
 * @param int $qid
 *   NID for a specific question instance.
 *
 * @param array $answer
 *   An array specifying the value to store in the response.
 *
 * @param bool $is_new
 *   Boolean indicating whether or not this function is being called to generate a new response object.
 *   Defaults to FALSE. If TRUE, field_response_updated will not be modified.
 *
 * @return int
 *   The NID of the response which the answer was saved to.
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_api_set_response($app_id, $qid, $answer = array(), $is_new = FALSE) {
  // Set default answer.
  $default = array(
    'value' => '',
    'point' => 0,
  );
  $answer = array_merge($default, $answer);

  // Find response.
  $rid = pgh_api_find_response_id($app_id, $qid);
  if ($rid) {
    $response = node_load($rid);
    $wrapper = entity_metadata_wrapper('node', $response);
  }
  else {
    // Create a new response.
    $response = entity_create('node', array('type' => 'response'));
    $wrapper = entity_metadata_wrapper('node', $response);
    $wrapper->field_response_application->set($app_id);
    $wrapper->field_response_question->set($qid);
  }
  $wrapper->title = 'app_' . $app_id . '_q_' . $qid;
  if ($answer) {
    $wrapper->body = array(
      'value' => $answer['value']
    );
    $wrapper->field_response_point->set($answer['point']);
  }
  if (!$is_new) {
    $wrapper->field_response_updated->set(1);
  }
  $wrapper->save();
  node_save($response);
  return $response->nid;
}

/**
 * Save question value to response
 *
 * @param int $app_id
 *   NID for a specific application instance.
 *
 * @param int $qid
 *   NID for a specific question instance.
 *
 * @param array $value
 *   Quesiton value
 *
 * @return int
 *   The NID of the response which the answer was saved to.
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_api_save_response($app_id, $qid, $value) {
  $question = node_load($qid);
  $question_wrapper = entity_metadata_wrapper('node', $question);
  $type = $question_wrapper->field_question_type->value();
  $style = $question_wrapper->field_question_style->value();

  // Save response if the question expects a response.
  if (!in_array($type, array('html', 'container'))) {
    // Assign point.
    $points = $question_wrapper->field_question_points->value();

    $point = 0;
    switch ($type) {
      case 'text':
      case 'file':
        if (!empty($value) && !empty($points[0])) {
          $point = $points[0];
        }
        break;

      case 'selection':
        switch ($style) {
          case 'checkboxes':
            $options = $question_wrapper->field_question_options->value();
            $i = 0;
            foreach ($options as $option) {
              if (!empty($value[$option])) {
                $point += $points[$i];
              }
              $i++;
            }
            $value = serialize($value);
            break;

          default:
            if (is_numeric($value) && is_array($points) && !empty($points[$value])) {
              $point = $points[$value];
            }
            break;
        }
        break;

      default:
        // code...
        break;
    }

    $answer = array(
      'value' => $value,
      'point' => $point,
    );
    pgh_api_set_response($app_id, $qid, $answer);
  }
}

/**
 * Return an array of question nodes for a specified application nid.
 *
 * @param int $application_nid
 *   The NID of the application.
 *
 * @return array
 *   An array of Question nodes.
 */
function pgh_api_questions_for_application($application_nid) {
  $questions = array();
  $application = node_load($application_nid);
  $application_wrapper = entity_metadata_wrapper('node', $application);

  $application_type = $application_wrapper->field_application_type->value();
  $application_type_wrapper = entity_metadata_wrapper('node', $application_type);

  foreach ($application_type_wrapper->field_apptype_categories->getIterator() as $category_wrapper) {
    foreach ($category_wrapper->field_category_sections->getIterator() as $section_wrapper) {
      foreach ($section_wrapper->field_section_questions->getIterator() as $question_wrapper) {
        $questions[$question_wrapper->title->value()] = $question_wrapper->value();
      }
    }
  }

  return $questions;
}

/**
 * Calculate progress information for a specific application.
 *
 * Iterates through entire Question and Response set for the application and combines the
 * information into an array of data.
 *
 * @param int $application_nid
 *   NID for a specific application instance.
 *
 * @return array
 *   An array containing information about the progress of an application.
 *   Elements include:
 *   'total' - The total number of responses counted.
 *
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_api_progress_for_application($application_nid) {
  $progress = &drupal_static(__FUNCTION__);

  if (!isset($progress)) {
    $cache = cache_get('pgh_api_application_progress');
    $progress = $cache->data;
  }

  if (!is_array($progress)) {
    $progress = array();
    cache_set('pgh_api_application_progress', $progress, 'cache');
  }

  if (!isset($progress[$application_nid])) {
    $query = new EntityFieldQuery();
    $result = $query->entityCondition('entity_type', 'node')
                    ->propertyCondition('type', 'response')
                    ->fieldCondition('field_response_application', 'target_id', $application_nid)
                    ->execute();

    if (!isset($result['node'])) {
      return 0;
    }

    $question_count = 0;
    $response_count = 0;

    $response_nids = array_keys($result['node']);

    foreach ($response_nids as $response_nid) {
      $response = node_load($response_nid);
      $response_wrapper = entity_metadata_wrapper('node', $response);
      $question = $response_wrapper->field_response_question->value();
      $question_wrapper = entity_metadata_wrapper('node', $question);

      $countable_question_types = array('text', 'file', 'selection');

      if (in_array($question_wrapper->field_question_type->value(), $countable_question_types)) {
        $question_count++;
        if ($response_wrapper->field_response_updated->value()) {
          $response_count++;
        }
      }
    }

    if ($question_count == 0) {
      $progress[$application_nid] = 1;
    }
    else {
      $progress[$application_nid] = $response_count / $question_count;
    }

    cache_set('pgh_api_application_progress', $progress, 'cache');
  }

  return $progress[$application_nid];
}
