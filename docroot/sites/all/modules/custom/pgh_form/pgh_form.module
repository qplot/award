<?php

/**
 * @file
 * Module file for PGH Form. Handles displaying a form for filling out an application.
 *
 * @author Fang Jin <fang@designhammer.com>
 */

// Define a temp variable to hold the questions.
$_pgh_form_temp_section_questions_ = NULL;

// Define a temp variable to hold the validation errors.
// $pgh_temp_validation_errors = NULL;

/**
 * Implementation of hook_menu().
 */
function pgh_form_menu() {
  $items = array();

  $items['application/%node'] = array(
    'title' => 'View application',
    'description' => 'Fill out an application',
    'page callback' => 'pgh_form_application_page',
    'page arguments' => array(1),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
  );

  $items['application/%node/category/%'] = array(
    'title' => 'Fill out application',
    'description' => 'Fill out an application',
    'page callback' => 'pgh_form_category_page',
    'page arguments' => array(1, 3),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
  );

  $items['admin/config/development/pgh'] = array(
    'title' => 'PGH settings',
    'description' => 'Development settings for pgh award applicaitons',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('pgh_form_settings'),
    'access callback' => TRUE,
  );

  $items['application/%node/submit'] = array(
    'title' => 'Review application for submission',
    'description' => 'Review and submit an application',
    'page callback' => 'pgh_form_application_submit_page',
    'page arguments' => array(1),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
  );

  return $items;
}

/**
 * Add application form settings.
 */
function pgh_form_settings($form, &$form_state) {
  $form['pgh_form_max_questions'] = array(
    '#type' => 'textfield',
    '#title' => 'Max question per applications',
    '#default_value' => variable_get('pgh_form_max_questions', 100000),
  );

  $form['pgh_form_drupal_validate'] = array(
    '#type' => 'checkbox',
    '#title' => 'Use drupal validate upon submission',
    '#default_value' => variable_get('pgh_form_drupal_validate', FALSE),
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'submit'
  );

  return $form;
}

/**
 * Save application form settings.
 */
function pgh_form_settings_submit($form, &$form_state) {
  variable_set('pgh_form_max_questions', $form_state['values']['pgh_form_max_questions']);
  variable_set('pgh_form_drupal_validate', $form_state['values']['pgh_form_drupal_validate']);
}

/**
 * Implementation of hook_theme().
 */
function pgh_form_theme() {
  return array(
    'pgh_form_table' => array(
      'render element' => 'element'
    )
  );
}

/**
 * Theme function for PGH table-type questions.
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function theme_pgh_form_table($vars) {
  $element = $vars['element'];
  $parse = &$element['#layout'];

  // Prepare to theme a table.
  $header = array();
  $rows = array();
  $i = 0;
  foreach ($parse as $row) {
    // Treat every row to be the same, no header row.
    // First row is header.
    $data = array();
    foreach ($row as $cell) {
      // Check if cell is a question.
      $cell_data = $cell;
      // dsm($cell);
      if (substr($cell, 0, 5) == 'pghq_') {
        // Find the question.
        if ($qid = pgh_find_question_id($cell)) {
          $cell_data = render($element[$qid]);
        }
      }
      $data[] = array('data' => $cell_data);
    }
    $rows[] = $data;
  }

  return theme('table', array('header' => $header, 'rows' => $rows));
}

/**
 * Page callback to display an edit form for a specific application and category.
 *
 * @param object $application
 *   Node for a specific application instance.
 *
 * @return int
 *   MENU status constants.
 *
 * @author Jay Roberts <jay@designhammer.com>
 */
function pgh_form_application_page($application) {
  if (!$application) {
    return MENU_NOT_FOUND;
  }

  $application_wrapper = entity_metadata_wrapper('node', $application);
  $application_type = pgh_api_application_type_by_id($application_wrapper->field_application_type->value());
  $application_type_wrapper = entity_metadata_wrapper('node', $application_type);

  $first_category = NULL;

  if (isset($application_type_wrapper->field_apptype_categories)) {
    $first_category = $application_type_wrapper->field_apptype_categories[0]->value();
  }

  if (!$first_category) {
    return MENU_NOT_FOUND;
  }

  if (empty($first_category->title)) {
    drupal_set_message('Missing title for category ' . $first_category->nid);
    return MENU_NOT_FOUND;
  }

  drupal_goto('application/' . $application->nid . '/category/' . $first_category->title);
}

/**
 * Page callback to display an edit form for a specific application and category.
 *
 * @param object $application
 *   Node for a specific application instance.
 *
 * @param string $category_id
 *   The category id to display.
 *
 * @return string
 *   Rendered HTML for the page contents.
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_form_category_page($application, $category_id) {
  // Load the app by app_id.
  if ($application) {
    drupal_add_js(drupal_get_path('module', 'pgh_form') . '/js/pgh_form_settings.js', array('weight' => 2, 'scope' => 'footer'));
    drupal_add_js(drupal_get_path('module', 'pgh_form') . '/js/pgh_form.js', array('weight' => 2, 'scope' => 'footer'));

    $application_wrapper = entity_metadata_wrapper('node', $application);
    $application_type = pgh_api_application_type_by_id($application_wrapper->field_application_type->value());

    $application_type_wrapper = entity_metadata_wrapper('node', $application_type);

    // Set the page title.
    $title = $application_type_wrapper->body->value() ? $application_type_wrapper->body->value->raw() : '';
    drupal_set_title($application_wrapper->getIdentifier() . ' - ' . 'Application: ' . $title);

    // Find category_id if key is provided.
    if (!is_numeric($category_id)) {
      $category_id = pgh_api_find_nid($category_id, 'category');
    }

    return drupal_get_form('pgh_application_form', $application->nid, $category_id);;
  }
  else {
    drupal_not_found();
  }
}

/**
 * Form callback for a specific application and category.
 *
 * @param array $form
 *   Form array.
 *
 * @param array $form_state
 *   Form state array.
 *
 * @param int $app_id
 *   NID for a specific application instance.
 *
 * @param string $cat_id
 *   The category id to display.
 *
 * @return array
 *   A Drupal form array ready to be rendered.
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_application_form($form, &$form_state, $app_id = NULL, $cat_id = NULL) {
  // TODO: This is a very brittle way to skip already rendered questions. We should not use globals for this.
  // Also, it leaves technically invalid question specifiers in the Section objects.
  // Questions contained within tables/containers should be filtered out at migration time, not render time.
  global $_pgh_form_temp_section_questions_;

  $form = array();

  if (empty($app_id) || empty($cat_id)) {
    return $form;
  }

  // Load category by name, can be id as well.
  $cat = node_load($cat_id);
  $questions = array();

  if (!empty($cat->field_category_sections['und'])) {
    // For debugging purpose add a counter.
    $debug = 0;
    $total = variable_get('pgh_form_max_questions', 1000000000);

    $form['ajax_div'] = array(
      '#markup' => '',
      '#prefix' => '<div id="pgh_form_ajax_div">',
      '#suffix' => '</div><!-- #question --><br /><br />',
    );

    foreach ($cat->field_category_sections['und'] as $sec_id) {
      if ($sec = node_load($sec_id['target_id'])) {
        $sec_wrapper = entity_metadata_wrapper('node', $sec);

        $caption = $sec_wrapper->field_section_label->value();

        // Add a fieldset to hold section info.
        if (!empty($caption)) {
          $fieldset = 'fieldset_' . $sec_wrapper->title->value();
          $form[$fieldset] = array(
            '#type' => 'fieldset',
            '#title' => t($caption),
            '#collapsible' => FALSE,
            '#collapsed' => FALSE,
          );
        }
        else {
          $fieldset = 'container_' . $sec_wrapper->title->value();
          $form[$fieldset] = array(
            '#type' => 'container',
          );
        }

        // Add all question inside this section.
        $_pgh_form_temp_section_questions_ = drupal_map_assoc($sec_wrapper->field_section_questions->raw());
        // dsm($_pgh_form_temp_section_questions_);
        foreach ($sec_wrapper->field_section_questions->getIterator() as $q_wrapper) {

          if (!isset($_pgh_form_temp_section_questions_[$q_wrapper->getIdentifier()])) {
            continue;
          }

          $major = 'question_' . $q_wrapper->label();

          $form[$fieldset][$major][$q_wrapper->getIdentifier()] = pgh_form_render_question_layout($q_wrapper->value(), $app_id);

          $debug = $debug + 1;
          if ($debug == $total) {
            break;
          }

        }
        if ($debug == $total) {
          break;
        }
      }
    }
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Submit',
  );

  $form['application'] = array(
    '#type' => 'hidden',
    '#value' => $app_id
  );
  return $form;
}


/**
 * Application form AJAX callback.
 *
 * @param array $form
 *   Form array.
 *
 * @param array $form_state
 *   Form state array.
 *
 * @author  Fang Jin <fang@designhammer.com>
 */
function pgh_application_form_element_callback($form, &$form_state) {
  if (empty($form_state['triggering_element']['#parents'][0])) {
    return;
  }
  // Find the question.
  $qid = $form_state['triggering_element']['#parents'][0];
  $question = node_load($qid);
  $wrapper = entity_metadata_wrapper('node', $question);

  // Save the response value.
  $app_id = $form_state['values']['application'];
  $value = $form_state['values'][$qid];
  pgh_api_save_response($app_id, $qid, $value);

  // Validate the response.
  $error_msg = '<div id="error-container-' . $wrapper->title->value() . '">';
  if ($validations = $wrapper->field_question_validation->value()) {
    $errors = pgh_api_validate_question_value($validations, $value);
    if ($errors) {
      $error_msg .= pgh_form_error_html($wrapper->title->value(), $errors);
    }
  }
  $error_msg .= '</div><!-- #error-container -->';

  return $error_msg;
}

/**
 * Application form submit handler. Handles submission of the fields in a single category of the application.
 *
 * Determines the value to be stored and calculates the points for each question. Stores this information
 * in the appropriate response node.
 *
 * @param array $form
 *   Form array.
 *
 * @param array $form_state
 *   Form state array.
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_application_form_submit($form, &$form_state) {
  // Since preparation have all response ready, we just need to save one by one.
  $app_id = $form_state['values']['application'];

  foreach ($form_state['values'] as $qid => &$value) {
    // Assume all question has number.
    if (is_numeric($qid)) {

      // Media selector bug, need to access from input.
      if (isset($value['fid'])) {
        $value = $form_state['input'][$qid]['fid'];
      }

      pgh_api_save_response($app_id, $qid, $value);
    }
  }
}

/**
 * Builds a Drupal Form API element for a specific question in an application.
 *
 * Sets the default value to a provided answer in a response node if one is available.
 *
 * @param object $question
 *   A fully-loaded question node.
 *
 * @param int $app_id
 *   NID for a specific application instance.
 *
 * @return array
 *   A Drupal Form API element representing the supplied question.
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_form_render_question($question, $app_id = NULL) {
  $form = array();

  $wrapper = entity_metadata_wrapper('node', $question);
  $type = $wrapper->field_question_type->value();
  $style = $wrapper->field_question_style->value();

  // Store any question-specific administrative information in $admin_info. Items will be
  // included after the question prompt if the user is an awards administrator.
  $admin_info = array();
  $admin_info[] = ' <small>[' . $wrapper->title->value() . ']</small> ';
  $admin_info[] = '<small>' . l(t('[Q]'), 'node/' . $wrapper->getIdentifier() . '/edit') . '</small>';

  // Prepare response for question expecting a response.
  if (!in_array($type, array('html', 'container'))) {
    $rid = pgh_api_find_response_id($app_id, $wrapper->getIdentifier());
    if (!$rid) {
      $rid = pgh_api_set_response($app_id, $wrapper->getIdentifier());
    }

    $answer = pgh_api_get_response($app_id, $wrapper->getIdentifier());
    $admin_info[] = '<small>' . l(t('[R]'), 'node/' . $rid . '/edit') . '</small>';
    $admin_info[] = ' <small>[P' . intval($answer['point']) . ']</small> ';

    // Only set the default value if a response has been provided.
    if ($answer['updated']) {
      $form['#default_value'] = $answer['value'];
    }
  }

  $form['#title'] = '<div class="question-desc">' . check_markup($wrapper->field_question_prompt->value(), 'question_text', '', FALSE) . '</div><!-- .question-desc -->';

  if (user_access('administer awards system')) {
    $form['#title'] .= ' ' . implode(' ', $admin_info);
  }

  // Make sure the flat return.
  $form['#tree'] = FALSE;

  $form['#question_id'] = $wrapper->getIdentifier();

  // Dependency display.
  if ($parent_qid = $wrapper->field_question_parent_qid->value()) {
    $form['#states'] = pgh_form_question_states($question);
  }

  // Ajax processing.
  $form['#ajax'] = array(
    'callback' => 'pgh_application_form_element_callback',
    'wrapper' => 'error-container-' . $wrapper->title->value(),
  );

  // Perform additional question-type specific processing.
  switch ($type) {
    case 'html':
    case 'container':
      $form['#type'] = 'item';
      $form['#markup'] = t($form['#title']);
      unset($form['#title']);
      break;

    case 'text':
      switch ($style) {
        case 'textarea':
          $form['#type'] = 'textarea';
          $form['#size'] = 3;
          break;

        default:
          $form['#type'] = 'textfield';
          $form['#size'] = NULL;
          break;
      }
      break;

    case 'selection':
      $options = $wrapper->field_question_options->value();

      switch ($style) {
        case 'dropdown':
          $form['#type'] = 'select';
          $form['#options'] = $options;
          break;

        case 'default':
        case 'radios':
          $form['#type'] = 'radios';
          $form['#options'] = $options;
          break;

        case 'checkboxes':
          $form['#type'] = 'checkboxes';
          $form['#options'] = drupal_map_assoc($options);
          $form['#default_value'] = unserialize($form['#default_value']);
          if (empty($answer['value'])) {
            unset($form['#default_value']);
          }
          break;

        default:
          // $form['#markup'] = '<b><em>Not Implemented Style - ' . $style . '</em></b>';
          $form['#prefix'] = '<b><em>Not Implemented Style - ' . $style . '</em></b>';
          $form['#type'] = 'textfield';
          $form['#size'] = NULL;
          break;
      }

      break;

    case 'file':
      $media = array(
        '#type' => 'media',
        '#input' => TRUE,
        '#media_options' => array(
          'global' => array(
            'types' => array('document'),
            'schemes' => array('http'),
          ),
        ),
        '#attached' => array(),
        '#extended' => TRUE,
        '#tree' => TRUE,
        '#value' => !empty($answer['value']) ? array('fid' => $answer['value']) : '',
      );
      $form = array_merge($form, $media);
      break;

    default:
      // $form['#markup'] = '<b><em>Not Implemented Type - ' . $type . '</em></b>';
      $form['#type'] = 'textfield';
      $form['#size'] = NULL;
      $form['#prefix'] = '<b><em>Not Implemented Type - ' . $type . '</em></b>';
      break;
  }

  $form['#description'] = '<div id="error-container-' . $wrapper->title->value() . '">';

  // Add error validation to description.
  if ((!empty($answer['updated'])) && ($validations = $wrapper->field_question_validation->value())) {
    $errors = pgh_api_validate_question_value($validations, $answer['value']);
    if ($errors) {
      $form['#description'] .= pgh_form_error_html($wrapper->title->value(), $errors);
    }
  }

  $form['#description'] .= '</div><!-- #error-container -->';

  $data_attributes = array();

  // Add id and classes for theming.
  $classes = array(
    'question',
    'question-type-' . $type,
    'question-style-' . $style,
  );

  if ($parent_qid) {
    $classes[] = 'question-dependent';
    $classes[] = 'data-parent-id-question-' . $parent_qid;
    $data_attributes[] = 'data-parent-id="question-' . $parent_qid . '"';
  }

  $form['#prefix'] = '<div id="question-' . $wrapper->title->value() . '" class="' . implode($classes, ' ') . '" ' . implode($data_attributes, ' ') . '>';
  $form['#suffix'] = '</div><!-- #question -->';

  // Add default question id handling.
  // If no default value is set and a default question id is given, set it to default question response value.
  $form['#default_question_id'] = $wrapper->field_question_formula->value();
  if (empty($form['#default_value']) && !empty($form['#default_question_id'])) {
    // Fetch question.
    if ($fid = pgh_find_question_id($form['#default_question_id'])) {
      // Fetch the question response.
      if ($rid = pgh_api_find_response_id($app_id, $fid)) {
        $answer = pgh_api_get_response($app_id, $fid);
        $form['#default_value'] = $answer['value'];
      }
    }
  }

  // Mark this question as processed.
  global $_pgh_form_temp_section_questions_;
  unset($_pgh_form_temp_section_questions_[$wrapper->getIdentifier()]);

  return $form;
}

/**
 * Generate form questions with layout.
 */

/**
 * Builds a Drupal Form API element for a specific question and handles layout for 'container' type questions.
 *
 * If the question has a layout string specified, parse the layout and render it.
 *
 * This is not a recursive function. Questions with type 'container' may not contain other questions with
 * type 'container'.
 *
 * @param object $question
 *   A fully-loaded question node. If the question has a layout string, also render the layout.
 *
 * @param int $app_id
 *   NID for a specific application instance.
 *
 * @return array
 *   A Drupal Form API element representing the supplied question.
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_form_render_question_layout($question, $app_id = NULL) {
  $wrapper = entity_metadata_wrapper('node', $question);
  $type = $wrapper->field_question_type->value();
  $layout = $wrapper->field_question_layout->value();
  $prompt = check_markup($wrapper->field_question_prompt->value(), 'question_text', '', FALSE);

  if (!empty($layout) && ($type == 'container')) {
    // Print the container parent element.
    $parse = pgh_parse_layout($layout);

    // We should be able to add prompt to the prefix section.
    $result = array(
      '#prefix' => $prompt,
      // '#postfix' => '',
      '#tree' => TRUE,
      '#theme' => 'pgh_form_table',
      '#layout' => $parse,
    );

    // Print child elements.
    foreach ($parse as $row) {
      foreach ($row as $cell) {
        if (substr($cell, 0, 5) == 'pghq_') {
          // Find the question.
          if ($qid = pgh_find_question_id($cell)) {
            $child = node_load($qid);
            $result[$qid] = pgh_form_render_question($child, $app_id);
          }
        }
      }
    }
  }
  else {
    // This is the original without layout handling.
    $result = pgh_form_render_question($question, $app_id);
  }

  return $result;
}

/**
 * Returns markup for a div containing an error message for a specific question.
 *
 * @param string $question_id
 *   A question identifier.
 *
 * @param array $messages
 *   An array of messages to display to the end user.
 *
 * @return string
 *   An html string with a properly formatted error message.
 *
 * @author Jay Roberts <jay@designhammer.com>
 */
function pgh_form_error_html($question_id, $messages) {
  $output = '<div id="error-' . $question_id . '" class="content-incorrect">';
  foreach ($messages as $message) {
    $output .= '<span>' . $message . '</span>';
  }
  $output .= '</div><!-- #error -->';
  return $output;
}

/**
 * Return the visibility state array based on the supplied question node.
 *
 * This is the code that provides support for the "Dependant Question" feature.
 *
 * @param object $question
 *   The question node object.
 *
 * @return array
 *   The visibility state array supported by the Drupal form API.
 */
function pgh_form_question_states($question) {
  $wrapper = entity_metadata_wrapper('node', $question);

  // Load parent question.
  $parent_qid = $wrapper->field_question_parent_qid->value();
  $parent = pgh_find_question_id($parent_qid);
  $parent_question = node_load($parent);
  $pwrapper = entity_metadata_wrapper('node', $parent_question);
  $parent_type = $pwrapper->field_question_type->value();
  $parent_style = $pwrapper->field_question_style->value();

  $name = $pwrapper->getIdentifier();
  $value = $wrapper->field_question_parent_value->value();
  $input = '';
  switch ($parent_type) {
    case 'selection':
      switch ($parent_style) {
        // Multiple choices.
        case 'checkboxes':
          $name = $pwrapper->getIdentifier() . '[' . $value . ']';
          $input = array('checked' => TRUE);
          break;

        // Single choice, ex. radios.
        default:
          $options = $pwrapper->field_question_options->value();
          $value = array_search($value, $options);
          break;
      }
      break;

    default:
      // Noop. Dependant question display is currently only supported for the 'selection' question type.
      break;
  }
  if (empty($input)) {
    $input = array('value' => $value);
  }
  $result = array(
    'visible' => array(
      ':input[name="' . $name . '"]' => $input
    ),
  );

  return $result;
}

/**
 * Returns the NID for a question based on a supplied question id.
 *
 * @param string $key
 *   A question ID.
 *
 * @return int
 *   The NID for the supplied question id or 0 if not found.
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_find_question_id($key) {
  // TODO: This function accepts an ID and returns a NID. The naming makes it seem like it returns a question ID.
  // Should be renamed to pgh_api_nid_for_question($qid)
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
                  ->propertyCondition('type', 'question')
                  ->propertyCondition('title', $key)
                  ->execute();
  if (!empty($result['node'])) {
    $keys = array_keys($result['node']);
    return $keys[0];
  }
  else {
    return 0;
  }
}

/**
 * Parse a layout string into an array of labels and question ids.
 *
 * Layout strings represent 2-dimensional arrays with columns delimited by commas and
 * rows delimited by semicolons. Whitespace and newlines around elements are removed.
 *
 * Example:
 *
 * Fruit,  Color,             Taste,              Notes;
 * Apple,  pghq_color_apple,  pghq_taste_apple,   pghq_notes_apple;
 * Pear,   pghq_color_pear,   pghq_taste_pear,    pghq_notes_pear;
 * Banana, pghq_color_banana, pghq_taste_banana,  pghq_notes_banana;
 *
 * @param string $layout
 *   The layout string to parse.
 *
 * @return array
 *   A parsed array matching the structure inidicated by the layout string. Array values are strings.
 */
function pgh_parse_layout($layout) {
  $rows = array_map('trim', explode('||', $layout));
  $result = array();
  foreach ($rows as $row) {
    $result[] = array_map('trim', explode('|', $row));
  }
  return $result;
}

/**
 * Display completion status of the application and notes on any validation errors.
 *
 * If the application is complete and has no errors allow the user to submit the application which
 * will set the status to submitted and prevent any additional changes from being made.
 *
 * @param object $application
 *   The application node to submit.
 *
 * @return array
 *   A renderable array for the submit form.
 *
 * @author  Jay Roberts <jay@designhammer.com>
 */
function pgh_form_application_submit_page($application) {
  drupal_add_js(drupal_get_path('module', 'pgh_form') . '/js/pgh_form_submission.js', array('weight' => 2, 'scope' => 'footer'));

  $categories = pgh_api_categories_for_application($application->nid);

  $rows = array();

  $incomplete_categories = FALSE;
  $invalid_categories = FALSE;

  foreach ($categories as $category) {
    $category_wrapper = entity_metadata_wrapper('node', $category);
    $progress = pgh_api_progress_for_category($application->nid, $category->nid);

    if ($progress < 1) {
      $incomplete_categories = TRUE;
    }

    $validation = '<span class="valid">Valid</span>';
    $category_errors = pgh_api_errors_for_category($application->nid, $category->nid);

    if ($category_errors) {
      $validation = '<span class="invalid">There are validation errors in this category</span>';
      $validation .= '<div class="error-list" style="border: 1px solid red; width: 100%;">';
      $validation .= '<span>You can click and error below to go to the question it refers to.</span>';

      foreach ($category_errors as $qid => $question_errors) {
        foreach ($question_errors as $error) {
          $options = array(
            'fragment' => 'question-' . $qid,
          );
          $validation .= l($error, 'application/' . $application->nid . '/category/' . $category->title, $options) . '<br />';
        }
      }

      $validation .= '</div>';

      $invalid_categories = TRUE;
    }

    $category_name = $category_wrapper->body->value() ? $category_wrapper->body->value->raw() : 'Missing title for category ' . $category->nid;

    $rows[] = array(
      l($category_name, 'application/' . $application->nid . '/category/' . $category->title),
      pgh_progress_bar($progress),
      $validation,
    );
  }

  $output = array();
  $output['categories'] = array(
    '#theme' => 'table',
    '#header' => array('Category', 'Progress', 'Validation'),
    '#rows' => $rows,
  );

  if ($invalid_categories) {
    $output['incomplete_categories'] = array(
      '#prefix' => '<div class="submission_warning">',
      '#markup' => t('Some of the categories have validation errors. Please review the marked categories for missing or invalid responses.'),
      '#suffix' => '</div>',
    );
  }
  else {
    $output['incomplete_categories'] = array(
      '#prefix' => '<div class="submission_message">',
      '#markup' => t('Please ensure your application is complete. You will not be able to make changes after submitting.'),
      '#suffix' => '</div>',
    );
    $output['submit_form'] = drupal_get_form('pgh_form_application_submit_form', $application);
  }

  return $output;
}

/**
 * Form callback for application submission.
 *
 * @param array $form
 *   Form array.
 *
 * @param array $form_state
 *   Form state array.
 *
 * @param object $application
 *   Node for a specific application instance.
 *
 * @return array
 *   A form array.
 *
 * @author Jay Roberts <jay@designhammer.com>
 */
function pgh_form_application_submit_form($form, &$form_state, $application) {
  $form = array();

  $form['application_nid'] = array(
    '#type' => 'hidden',
    '#value' => $application->nid,
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Submit this application',
  );
  return $form;
}

/**
 * Form submission handler for application submission.
 *
 * @param array $form
 *   Form array.
 *
 * @param array $form_state
 *   Form state array.
 *
 * @return array
 *   A form array.
 *
 * @author Jay Roberts <jay@designhammer.com>
 */
function pgh_form_application_submit_form_submit($form, &$form_state) {
  $application = node_load($form_state['values']['application_nid']);
  $application_wrapper = entity_metadata_wrapper('node', $application);
  $application_wrapper->field_application_status->set('submitted');
  $application_wrapper->save();

  drupal_set_message('The application has been submitted successfully');
  drupal_goto('dashboard');
}
