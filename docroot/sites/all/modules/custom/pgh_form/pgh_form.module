<?php

/**
 * @file
 * Module file for PGH Form. Handles displaying a form for filling out an application.
 *
 * @author Fang Jin <fang@designhammer.com>
 */

// Define a temp variable to hold the temp questions.
$pgh_temp_section_questions = NULL;

/**
 * Implementation of hook_menu().
 */
function pgh_form_menu() {
  $items = array();

  // This is the primary locaion for editing a form. Users edit a single page/category worth of questions at a time.
  $items['application/%/category/%/edit'] = array(
    'title' => 'Fill Application',
    'description' => 'Fill an application',
    'page callback' => 'pgh_application_edit_form',
    'page arguments' => array(1, 3),
    'access callback' => TRUE,
  );

  return $items;
}

/**
 * Implementation of hook_theme().
 */
function pgh_form_theme() {
  return array(
    'pgh_form_table' => array(
      'render element' => 'element'
    )
  );
}

/**
 * Theme function for PGH table-type questions.
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function theme_pgh_form_table($vars) {
  $element = $vars['element'];
  $parse = &$element['#layout'];

  // Prepare to theme a table.
  $rows = array();
  $i = 0;
  foreach ($parse as $row) {
    // First row is header.
    if ($i == 0) {
      $header = $row;
    }
    else {
      $data = array();
      foreach ($row as $cell) {
        // Check if cell is a question.
        $cell_data = $cell;
        // dsm($cell);
        if (substr($cell, 0, 5) == 'pghq_') {
          // Find the question.
          if ($qid = pgh_find_question_id($cell)) {
            $cell_data = render($element[$qid]);
          }
        }
        $data[] = array('data' => $cell_data);
      }
      $rows[] = $data;
    }
    $i = $i + 1;
  }

  return theme('table', array('header' => $header, 'rows' => $rows));
}

/**
 * Page callback to display an edit form for a specific application and category.
 *
 * @param int $app_id
 *   NID for a specific application instance.
 *
 * @param string $cat_id
 *   The category id to display.
 *
 * @return string
 *   Rendered HTML for the page contents.
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_application_edit_form($app_id, $cat_id) {
  // Load the app by app_id.
  if ($app = node_load($app_id)) {
    $app_wrapper = entity_metadata_wrapper('node', $app);
    $apptype = $app_wrapper->field_application_type->value();

    $type_wrapper = entity_metadata_wrapper('node', $apptype);

    // Set the page title.
    $title = $type_wrapper->body->value->raw();
    drupal_set_title($app_wrapper->getIdentifier() . ' - ' . 'Application: ' . $title);

    // List all categories of the app.
    $lists = array();
    foreach ($type_wrapper->field_apptype_categories->getIterator() as $cat_wrapper) {
      $cat_label = $cat_wrapper->getIdentifier() . ' - ' . $cat_wrapper->body->value->raw();
      $lists[] = l($cat_label, 'application/' . $app_id . '/category/' . $cat_wrapper->getIdentifier() . '/edit');
    };

    $out['categories'] = array(
      '#theme' => 'item_list',
      '#items' => $lists,
      '#title' => t(''),
      // '#attributes' => array('class' => array('my-links')),
    );

    // Render category form.
    $out['forms'] = drupal_get_form('pgh_application_form', $app_id, $cat_id);

    return drupal_render($out);

  }

  return '123';
}

/**
 * Form callback for a specific application and category.
 *
 * @param array $form
 *   Form array.
 *
 * @param array $form_state
 *   Form state array.
 *
 * @param int $app_id
 *   NID for a specific application instance.
 *
 * @param string $cat_id
 *   The category id to display.
 *
 * @return array
 *   A Drupal form array ready to be rendered.
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_application_form($form, &$form_state, $app_id = NULL, $cat_id = NULL) {
  // TODO: This is a very brittle way to skip already rendered questions. We should not use globals for this.
  // Also, it leaves technically invalid question specifiers in the Section objects.
  // Questions contained within tables/containers should be filtered out at migration time, not render time.
  global $pgh_temp_section_questions;

  $form = array();

  if (empty($app_id) || empty($cat_id)) {
    return $form;
  }

  // Load category by name, can be id as well.
  $cat = node_load($cat_id);
  $questions = array();

  if (!empty($cat->field_category_sections['und'])) {
    // For debugging purpose add a counter.
    $debug = 0; $total = 1;
    foreach ($cat->field_category_sections['und'] as $sec_id) {
      if ($sec = node_load($sec_id['target_id'])) {
        $sec_wrapper = entity_metadata_wrapper('node', $sec);

        $caption = $sec_wrapper->field_section_label->value();

        // Add a fieldset to hold section info.
        if (!empty($caption)) {
          $fieldset = 'fieldset_' . $sec_wrapper->title->value();
          $form[$fieldset] = array(
            '#type' => 'fieldset',
            '#title' => t($caption),
            '#collapsible' => TRUE,
            '#collapsed' => FALSE,
          );
        } else {
          $fieldset = 'container_' . $sec_wrapper->title->value();
          $form[$fieldset] = array(
            '#type' => 'container',
          );
        }

        // Add all question inside this section.
        $pgh_temp_section_questions = drupal_map_assoc($sec_wrapper->field_section_questions->raw());
        // dsm($pgh_temp_section_questions);
        foreach ($sec_wrapper->field_section_questions->getIterator() as $q_wrapper) {

          if (!isset($pgh_temp_section_questions[$q_wrapper->getIdentifier()])) {
            continue;
          }

          $major = 'question_' . $q_wrapper->label();

          $form[$fieldset][$major][$q_wrapper->getIdentifier()] = pgh_gen_form_question_layout($q_wrapper->value(), $app_id);

          $debug = $debug + 1;
          if ($debug == $total) {
            break;
          }

        }
        if ($debug == $total) {
          break;
        }
      }
    }
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Submit',
  );

  $form['application'] = array(
    '#type' => 'hidden',
    '#value' => $app_id
  );

  return $form;
}

/**
 * Application form element validation handler.
 *
 * @param array $element
 *   Form element.
 *
 * @param array $form_state
 *   Form state array.
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_application_form_element_validate($element, &$form_state) {
  dsm($element);
  // grab question id, this might not be always the case, need FIX
  $qid = $element['#parents'][0];

  if ($validation = $element['#question_validation']) {

  }
  // grab value submitted,
  // dsm($form_state);
}

/**
 * Application form submit handler. Handles submission of the fields in a single category of the application.
 *
 * Determines the value to be stored and calculates the points for each question. Stores this information
 * in the appropriate response node.
 *
 * @param array $form
 *   Form array.
 *
 * @param array $form_state
 *   Form state array.
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_application_form_submit($form, &$form_state) {
  // TODO: Calculate the points for a given question in a separate API function (
  // i.e. pgh_api_score_for_question($app_id, $qid, $answer).

  // Since preparation have all response ready, we just need to save one by one.
  $app_id = $form_state['values']['application'];

  foreach ($form_state['values'] as $qid => &$value) {

    // Assume all question has number.
    if (is_numeric($qid)) {
      $question = node_load($qid);
      $question_wrapper = entity_metadata_wrapper('node', $question);
      $type = $question_wrapper->field_question_type->value();
      $style = $question_wrapper->field_question_style->value();

      // Save response if the question expects a response.
      if (!in_array($type, array('html', 'container'))) {
        // Assign point.
        $points = $question_wrapper->field_question_points->value();

        $point = 0;
        switch ($type) {
          case 'text':
            if (!empty($value) && !empty($points[0])) {
              $point = $points[0];
            }
            break;

          case 'selection':
            switch ($style) {
              case 'checkboxes':
                $options = $question_wrapper->field_question_options->value();
                $i = 0;
                foreach ($options as $option) {
                  if (!empty($value[$option])) {
                    $point += $points[$i];
                  }
                  $i++;
                }
                $value = serialize($value);
                break;

              default:
                if (is_numeric($value) && is_array($points) && !empty($points[$value])) {
                  $point = $points[$value];
                }
                break;
            }
            break;

          case 'file':
            $value = $form_state['input']['fid'];
            break;

          default:
            // code...
            break;
        }

        $answer = array(
          'value' => $value,
          'point' => $point,
        );
        pgh_set_response($app_id, $qid, $answer);
      }
    }
  }
}

/**
 * Builds a Drupal Form API element for a specific question in an application.
 *
 * Sets the default value to a provided answer in a response node if one is available.
 *
 * @param object $question
 *   A fully-loaded question node.
 *
 * @param int $app_id
 *   NID for a specific application instance.
 *
 * @return array
 *   A Drupal Form API element representing the supplied question.
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_gen_form_question($question, $app_id = NULL) {
  $wrapper = entity_metadata_wrapper('node', $question);
  $type = $wrapper->field_question_type->value();
  $prompt = $wrapper->field_question_prompt->value();
  $style = $wrapper->field_question_style->value();

  // Prepare response for question expecting a response.
  $answer = array('value' => '', 'point' => 0);
  $response_edit = '';
  $point_edit = '';
  if (!in_array($type, array('html', 'container'))) {
    $rid = pgh_get_response($app_id, $wrapper->getIdentifier(), $answer);
    if (!$rid) {
      pgh_set_response($app_id, $wrapper->getIdentifier());
    }
    $response_edit = '<small>' . l(t('[R]'), 'node/' . $rid . '/edit') . '</small>';
    $point_edit = ' <small>[P' . intval($answer['point']) . ']</small> ';
  }

  $form = array();
  $question_edit = '<small>' . l(t('[Q]'), 'node/' . $wrapper->getIdentifier() . '/edit') . '</small>';
  $form['#title'] = $prompt . ' ' .
                    $question_edit . ' ' .
                    $response_edit . ' ' .
                    $point_edit;

  $form['#default_value'] = $answer['value'];
  // Make sure the flat return.
  $form['#tree'] = FALSE;
  // Validation
  $form['#question_id'] = $wrapper->getIdentifier();
  $form['#question_validate'] = $wrapper->field_question_validation->value();
  $form['#element_validate'] = array('pgh_application_form_element_validate');

  // Based on different question type.
  switch ($type) {
    case 'html':
      $form['#markup'] = $form['#title'];
      unset($form['#title']);
      break;

    case 'container':
      $form['#markup'] = $form['#title'];
      unset($form['#title']);
      break;

    case 'text':
      $form['#type'] = 'textfield';
      $form['#size'] = NULL;
      break;

    case 'selection':
      $options = $wrapper->field_question_options->value();

      switch ($style) {
        case 'dropdown':
          $form['#type'] = 'select';
          $form['#options'] = $options;
          break;

        case 'default':
        case 'radios':
          $form['#type'] = 'radios';
          $form['#options'] = $options;
          break;

        case 'checkboxes':
          $form['#type'] = 'checkboxes';
          $form['#options'] = drupal_map_assoc($options);
          $form['#default_value'] = unserialize($form['#default_value']);
          if (empty($answer['value'])) {
            unset($form['#default_value']);
          }
          break;

        default:
          // $form['#markup'] = '<b><em>Not Implemented Style - ' . $style . '</em></b>';
          $form['#prefix'] = '<b><em>Not Implemented Style - '. $style . '</em></b>';
          $form['#type'] = 'textfield';
          $form['#size'] = NULL;
          break;
      }

      break;

    case 'file':
      $form = array(
        '#type' => 'media',
        '#title' => t($prompt),
        '#input' => TRUE,
        '#media_options' => array(
          'global' => array(
            'types' => array('document'),
            'schemes' => array('http'),
          ),
        ),
        '#description' => t('Pick a video file to upload.'),
        '#attached' => array(),
        '#extended' => TRUE,
        // '#value' => !empty($answer['value'])?array('fid' => $answer['value']):'',
      );
      break;

    default:
      // $form['#markup'] = '<b><em>Not Implemented Type - ' . $type . '</em></b>';
      $form['#type'] = 'textfield';
      $form['#size'] = NULL;
      $form['#prefix'] = '<b><em>Not Implemented Type - '. $type . '</em></b>';
      break;
  }

  // Mark this question has been processed.
  global $pgh_temp_section_questions;
  unset($pgh_temp_section_questions[$wrapper->getIdentifier()]);

  return $form;
}

/**
 * Generate form questions with layout.
 */

/**
 * Builds a Drupal Form API element for a specific question and handle layout for 'container' type questions.
 *
 * If the question has a layout string specified, parse the layout and render it.
 *
 * This is not a recursive function. Questions with type 'container' may not contain other questions with
 * type 'container'.
 *
 * @param object $question
 *   A fully-loaded question node. If the question has a layout string, also render the layout.
 *
 * @param int $app_id
 *   NID for a specific application instance.
 *
 * @return array
 *   A Drupal Form API element representing the supplied question.
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_gen_form_question_layout($question, $app_id = NULL) {
  $wrapper = entity_metadata_wrapper('node', $question);
  $type = $wrapper->field_question_type->value();
  $layout = $wrapper->field_question_layout->value();
  $prompt = $wrapper->field_question_prompt->value();

  if (!empty($layout) && ($type == 'container')) {
    // Print the container parent element.
    $parse = pgh_parse_layout($layout);

    // We should be able to add prompt to the prefix section.
    $result = array(
      '#prefix' => $prompt,
      // '#postfix' => '',
      '#tree' => TRUE,
      '#theme' => 'pgh_form_table',
      '#layout' => $parse,
    );

    // Print child elements.
    foreach ($parse as $row) {
      foreach ($row as $cell) {
        if (substr($cell, 0, 5) == 'pghq_') {
          // Find the question.
          if ($qid = pgh_find_question_id($cell)) {
            $child = node_load($qid);
            $result[$qid] = pgh_gen_form_question($child, $app_id);
          }
        }
      }
    }
  }
  else {
    // This is the original without layout handling.
    $result = pgh_gen_form_question($question, $app_id);
  }

  return $result;
}

/**
 * Returns the NID for a question based on a supplied question id.
 *
 * @param string $key
 *   A question ID.
 *
 * @return int
 *   The NID for the supplied question id or 0 if not found.
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_find_question_id($key) {
  // TODO: This function accepts an ID and returns a NID. The naming makes it seem like it returns a question ID.
  // Should be renamed to pgh_api_nid_for_question($qid)
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
                  ->propertyCondition('type', 'question')
                  ->propertyCondition('title', $key)
                  ->execute();
  if (!empty($result['node'])) {
    $keys = array_keys($result['node']);
    return $keys[0];
  }
  else {
    return 0;
  }
}

/**
 * Returns the NID for a response based on a supplied application NID and question NID.
 *
 * @param int $app_id
 *   NID for a specific application instance.
 *
 * @param int $qid
 *   NID for a specific question instance.
 *
 * @return int
 *   The NID for the supplied question id or 0 if not found.
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_find_response_id($app_id, $qid) {
  // TODO: This function accepts an app NID and a question NID and returns a response NID. The naming makes
  // it seem like it returns a response ID (which is not a real thing in the system).
  // Should be renamed to pgh_api_nid_for_response($app_nid, $question_nid)
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
                  ->propertyCondition('type', 'response')
                  ->fieldCondition('field_response_application', 'target_id', $app_id)
                  ->fieldCondition('field_response_question', 'target_id', $qid)
                  ->execute();
  if (!empty($result['node'])) {
    $keys = array_keys($result['node']);
    return $keys[0];
  }
  else {
    return 0;
  }
}

/**
 * Load the nid of the response for a given question.
 *
 * @param int $app_id
 *   NID for a specific application instance.
 *
 * @param int $qid
 *   NID for a specific question instance.
 *
 * @param array $response
 *   A response array, passed by reference. This will be set to an array containing 'value' and 'points' elements.
 *
 * @return int
 *   The NID for the response object matching the supplied question/application identifiers.
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_get_response($app_id, $qid, &$response) {
  // TODO: Functions MUST NOT alter data by reference.
  // Refactor this to remove the $response setting behavior.
  $rid = pgh_find_response_id($app_id, $qid);
  if ($rid) {
    $response = node_load($rid);
    $wrapper = entity_metadata_wrapper('node', $response);

    $response = array(
      'value' => $wrapper->body->value->raw(),
      'point' => $wrapper->field_response_point->value(),
    );
    return $wrapper->getIdentifier();
  }

  return 0;
}

/**
 * Set question response
 */

/**
 * Sets the stored value for the response to a specific application/question.
 *
 * @param int $app_id
 *   NID for a specific application instance.
 *
 * @param int $qid
 *   NID for a specific question instance.
 *
 * @param array $answer
 *   An array specifying the value to store in the response.
 *
 * @return int
 *   The NID of the response which the answer was saved to.
 *
 * @author Fang Jin <fang@designhammer.com>
 */
function pgh_set_response($app_id, $qid, $answer = array()) {
  // Set default answer.
  $default = array(
    'value' => '',
    'point' => 0,
  );
  $answer = array_merge($default, $answer);

  // Find response.
  $rid = pgh_find_response_id($app_id, $qid);
  if ($rid) {
    $response = node_load($rid);
    $wrapper = entity_metadata_wrapper('node', $response);
  }
  else {
    // Create a new response.
    $response = entity_create('node', array('type' => 'response'));
    $wrapper = entity_metadata_wrapper('node', $response);
    $wrapper->field_response_application->set($app_id);
    $wrapper->field_response_question->set($qid);
  }
  $wrapper->title = 'app_' . $app_id . '_q_' . $qid;
  if ($answer) {
    $wrapper->body = array(
      'value' => $answer['value']
    );
    $wrapper->field_response_point->set($answer['point']);
  }
  $wrapper->save();
  node_save($response);
  return $response->nid;
}

/**
 * Parse a layout string into an array of labels and question ids.
 *
 * Layout strings represent 2-dimensional arrays with columns delimited by commas and
 * rows delimited by semicolons. Whitespace and newlines around elements are removed.
 *
 * Example:
 *
 * Fruit,  Color,             Taste,              Notes;
 * Apple,  pghq_color_apple,  pghq_taste_apple,   pghq_notes_apple;
 * Pear,   pghq_color_pear,   pghq_taste_pear,    pghq_notes_pear;
 * Banana, pghq_color_banana, pghq_taste_banana,  pghq_notes_banana;
 *
 * @param string $layout
 *   The layout string to parse.
 *
 * @return array
 *   A parsed array matching the structure inidicated by the layout string. Array values are strings.
 */
function pgh_parse_layout($layout) {
  $rows = array_map('trim', explode(';', $layout));
  $result = array();
  foreach ($rows as $row) {
    $result[] = array_map('trim', explode(',', $row));
  }
  return $result;
}
